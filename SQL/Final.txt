sqluser55
Final
Ian Youn
86406
8/4/2021
8/4/2021

1. SELECT A.DNAME AS "dname", A.LOC AS "loc", COUNT(B.EMPNO) AS "Number of People", NVL(AVG(B.SAL),0) AS "Salary"
FROM DEPT A FULL OUTER JOIN EMP B
ON A.DEPTNO = B.DEPTNO
GROUP BY A.DNAME, A.LOC;

2. SELECT ENAME, CONCAT(LOWER(SUBSTR(ENAME,1,2)),TO_CHAR(HIREDATE,'MMDDYY')) AS "Username", TO_CHAR(HIREDATE,'MM/DD/YYYY') AS "Hire Date", ROUND(SAL,2) AS "Salary", TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE,6),'MONDAY'),'MM/DD/YYYY') AS "REVIEW DATE"
FROM EMP;

3a. CREATE TABLE EQUIPMENT (
equipmentId NUMBER(5) NOT NULL,
equipmentDesc VARCHAR2(50),
equipmentPrice NUMBER(7,2) NOT NULL,
CONSTRAINT EQUIPMENT_IDPRICE_PK PRIMARY KEY (equipmentId, equipmentPrice));

3b. CREATE TABLE RENTAL (
Rentalid NUMBER(5) NOT NULL,
RentalDate DATE NOT NULL,
equipmentId NUMBER(5) NOT NULL,
equipmentPrice NUMBER(7,2) NOT NULL,
Status NUMBER(1) NOT NULL CHECK (Status < 7),
CONSTRAINT RENTAL_NUMBERDATE_PK PRIMARY KEY(Rentalid, RentalDate),
CONSTRAINT RENTAL_EQUIPIDPRICE_FK FOREIGN KEY (equipmentId, equipmentPrice) REFERENCES EQUIPMENT (equipmentId, equipmentPrice));


4. INSERT INTO EQUIPMENT VALUES (1, 'BLUE HAMMER', 9.99);
INSERT INTO RENTAL VALUES (1, '04-AUG-21', 1, 9.99, 1);

5. SELECT A.*, B.Status
FROM EQUIPMENT A, RENTAL B
WHERE A.equipmentId = B.equipmentId AND A.equipmentPrice = B.equipmentPrice;

6. CREATE TABLESPACE tbs_01 
DATAFILE 'tbs_f1.dat' SIZE 10M
AUTOEXTEND ON NEXT 500K MAXSIZE UNLIMITED;

7. Indexes help improve the speed of queries on a specific column of a large database. It allows for faster access of rows in queries and reduces disk I/O. A bitmap index typically improves the calculation of boolean operators (AND/OR) within low-cardinality columns. When used in a join, the bitmap index allows for more efficient use of storage and faster querying. Function-based indexes will speed up queries that use that specific function. For example, if I am using a lot of queries where I need to get the lowercase version (basically queries where capitalization doesn't matter) of a name, I would create an index using the lower function on the name column. B-tree indexes generally reduce the times of all queries by performing a binary-search-esque algorithm when searching for data.

8. Of the four main partitioning types (range, hash, list, and composite),  hashing is the most efficient as it will check the table's data generally and divide it automatically. Range and list partitions must check the data for certain restrictions to divide the data, making these partitions take extra time when setting up. Additionally, range and list partitions are manually set by the user for constraints, whereas hash partitions are automatically configured. Composite partitions are combinations of two or more of the other types of partitioning, making them obviously slower as the data must be partitioned multiple times.

